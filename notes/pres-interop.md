# Rust/LUA/msgpack interop: почему так сложно?

## Введение

Если слушать главу компании, то мы разрабатываем распределённую субд на расте
(до недавнего времени ещё и сервер приложений, но рынку это оказалось не нужно).
И если очень очень сильно прищуриться, то это действительно так, но всерьёз к
этому маркетинговому лозунгу относиться не стоит. Более точным на мой взгляд
было бы сказать "мы разрабатываем набор расширений для tarantool, которые
позволят делать на нём решения и использовать его как распределённую субд".
Отсюда становится понятно, при чём здесь луа и мсжпак.

Мсжпак это ядро тарантула (буквально, см. src/lib/core/mp_*). Тарантул =
tuple storage, tuple = msgpack. От него мы уже никогда не избавимся.

Луа это де факто язык для расширений и приложений на тарантуле, на нём написаны
управление схемой в тарантуле, модуль шардирования данных vshard, кластер
менеджер cartridge. Поэтому если ты пишешь код под тарантул, тот в любом случае
столкнёшься с луа.

Раст это стрёмная смесь c++ и ml (ocaml, haskel), который набирает популярность
засчёт качественного туллинга (cargo, rust-analyzer) и сказок про бесплатную
эффективность на уровне С одновременно с memory-safety без сборки мусора. На
деле же представляет из себя язык с эффективностью на уровне Go и сборкой мусора
через подсчёт ссылок.

Для кого этот доклад:
   - для людей, которые пишут код на расте и луа и использует msgpack
     (все сотрудники picodata)
   - для людей, которые принимают решения, на чём люди пишут код
     (выбирают технологии)


~~~

Так как тарантул неотрывно связан и с мсжпаком и с луа, мы по крайней мере в
обозримом будущем от них полностью избавиться не сможем. Повторюсь, на луа
написана и часть самого тарантула и значительная часть экосистемы.

А это значит, что если мы хотим создать успешный продукт в таких условиях, мы
должны уметь эффективно пользоваться доступными ресурсами, то есть оперировать
между rust, lua и мсжпаком. Это одна из целей библиотеки tarantool-module.

Но зачем пользователям знать как устроено всё внутри? По-мимо того, что знание =
сила, и что понимание системы на низком уровне даёт много преимуществ? Кроме
этого из-за особенностей наших условий часто возникают ситуации, которые
чисто абстаргировать в библиотеке не получается, из-за которых у пользователей
могут возникуть проблемы с использованием её. А в этом докладе я как раз
расскажу о таких вещах.

Расскажу, почему некоторые вещи получились криво, и почему зачастую сделать
лучше очень сложно.

А также заодно расскажу о нескольких местах, которые можно было сделать лучше,
чтобы вы в будущем не совершали наших ошибок.


~~~

Есть библиотека tlua/tarantool-module, почему она отстой, потому что всё сложно:

Зачем пользователям это знать, и что им с этим делать?

- Зачем:
   - чтобы понимать как работать с библиотекой, и почему она такая кривая
       местами
   - чтобы знать, что делать в местах, где библиотека не помогает
- Что делать:
   - По возможности избегать необходимости в интеропе между луа и растом
   - Всегда выбирать простые решения

## Разница моделей данных rust/lua/msgpack

- lua bool: true/false -- всё просто. На этом простые случаи закончены.
- lua nil: не может быть элементом таблицы
- lua number: double precision floating point number
   - msgpack integer / float
   - rust i8, u8, i16, u16, ..., isize, usize, i128, f32, f64 (NonZeroU64, ..)
- lua string:
   - msgpack string / bytes
   - rust string: String, &str, CString, &CStr, &[u8], OsString, Path, ...
- lua table:
   - sequence (индекс от 1) / hashtable
      - msgpack array / map
      - rust struct, enum, &[T], Vec<T>, HashMap<T>, HashSet<T>
- lua metamethods -> ?
- lua userdata / luajit cdata/ctype

- rust tuple:
   - msgpack array
   - lua sequence/lua multret
- rust struct Named { a: i32, b: String }
   - msgpack map
   - lua hashtable
- rust struct Unnamed(f32, bool) (для чего это вообще существует???)
   - msgpack array???
   - lua sequence??
- rust enum E { A, B, C }
   - msgpack string
   - lua string
- rust enum Expr { Add { l: L, r: R }, Not { e: E } }
   - msgpack map { tag: 'Add', value: { l: L, r: R } }
   - msgpack map { tag: 'Add', l: L, r: R }
   - msgpack map { l: L, r: R }
   - lua ...
- rust enum Expr { Add(L, R), Not(E) }
   - ?
- rust enum Result<T, E> { Ok(T), Err(E) }
- rust enum Option<T> { Some(T), None }
...


## Особенности tarantool-lua:
- box.NULL
- metamethods __serialize
- расширения cdata/userdata: decimal, fiber, tuple, datetime, ...
- встроенные перегруженные функции
- нет поддержки msgpack bytes
- поэтому большую часть нельзя вынести в tlua либу


## Особенности rust
- Serde: дефакто стандартное решение для сер/дериализации: описание
   - сложность модели: абстрактная модель Serializer/Deserializer
   Формат данных        -> [serde] -> struct, enum, Vec<T> ...
   [json,msgpack,...]
   - Не достаточно гибкости для краевых случаев

- rmp_serde баг с untagged

- Нет интроспекции ни рантайм ни компайлтайм: вместо этого трейты и проц макросы
- Нет специализации для трейтов: нужно явно прописывать реализацию либо
   - для каждого типа по отдельности impl MyTrait for i8; impl MyTrait for u8; impl MyTrait for String; ...
   - не больше одного: impl<T> MyTrait for T

- PartialEq vs Eq / ParitalOrd vs Ord
- Move-semantics/Borrow-checker/Lifetime constraints

## Ошибки проектирования tlua:
- tlua - отдельная библиотека, лучше было внести в tarantool-module
- tlua::Any[Hashable]LuaValue
   - no support for:
      - userdata
      - function
      - cdata
   - lossy:
      - table -> Vec<(Value, Value)>
      - number -> f64/i32
- LuaRead -> WrongType
   - изначально был Option, в случае ошибки получаешь None
   - сейчас не сильно лучше (пример сообщения об ошибке, примеры сообщений из serde_*)
- Параметрический полиморфизм
   - следствие: PushGuard<LuaTable<PushGuard<LuaFunction<PushGuard<...>>>>>
- Push[One][Into] _no_err



## tlua
    - PushGuard isn't flexible enough, cause: Parametric Polymorphism
    - LuaRead doesn't work with LuaTable as function parameters, cause: Parametric Polymorphism + borrow checker
    - trait Push is a mess, cause: type driven compile time checking
    - too many wrapper types, cause: trait system limitations
    - ViaMsgpack, cause: serde sucks + trait system

## msgpack
    - ToTupleBuffer & Encode: trait system limitations
    - RawBytes, RawByteBuf: trait system limitations + overabstraction

## serde





<div style="page-break-after: always;"></div>

- хотел рассказать про то, почему в тарантул модуле так сложно работать с луа,
  почему столько плохо работающих мест, и пока думал пришёл к выводу, что во
  всём виноват раст

- понятно, что вопрос выбора языа на место раста у нас не стоит, поэтому к концу
  рассказа попробую предложить какой-от набор подходов, который позволит
  упростить нашу жизнь

- кто я такой и как смею такое говорить? может это плохому танцору ноги мешают?

- пришёл в пикодату, потому что искал работу на расте, на плюсах не хотел
  писать, потому что там ситуация очень плачевная

- !!-- я в пикодате разрабатываю библиотеку и продукт. В обоих проектах я потрогал
  практически каждый кусок. По-мимо этого я делаю патчи в кору. Я пишу очень
  много кода, и реализую довольно большие фичи. По этим причинам мою точку
  зрения стоит принять во внимание --!!

- как мы сюда попали?

- раст рекламируется как безопасный и производительный язык. Здесь сразу
  всплывает первый подвох: на практике раст это либо безопасный язык и не
  безумно медленный, либо небезопасный и производительный. Это видно по любым
  бенчмаркам, которые занимают топы -- там всегда внутри unsafe код, с сырыми
  указателями и машинными операциями

- отсюда вывод: unsafe код не стоит бояться, его стоит понимать и уметь
  использовать

- а производительность нужна не всегда, часто лучше выбрать безопасность
  давайте посмотрим как раст нам в этом поможет

- раст и луа это фундаментально несовместимые языки
    - луа -- максимально динамический:
        - максимально нестрогая минималистичная типизация:
            - автопреобразование числовых типов
            - смысл таблиц меняется в зависимости от контекста
            - не поддерживает юникод
        - стэковый api: любая операция мутирует общее состояние
    - раст -- максимально статический:
        - наказывает за переиспользование типов
            - enum заставляет дублировать поля
            - traitы заставляют плодить новые типы
            - &str, String, CStr, &[u8], Path, ...
        - наказывает за нестрогость
            - проверка ошибок обязательна в каждом месте использования
        - наказывает за мутирование
            - иметь две &mut на один и тот же объект незаконно
        - наказывает за ссылки
            - вездесущий борроу чекер
            - любой код с ссылками -- дженерик код
    - невозможно построить хорошую прослойку
        - либо она не будет полноценно укладываться в парадигму раста
            - unsafe
        - либо она будет ужасна в использовании
        - на выглаживание корнер кейсов уйдёт вечность
    - что же тогда делать?
        - сокращать площадь соприкосновения раста и луа в своих проектах
        - не ныть и чинить корнер кейсы руками

- мсжпак -- не (самая большая) проблема, проблема в serde
    - serde слишком дженерик и при этом недостаточно гибкий
        - раст [Serialize] <-(модель данных serde)-> [Serializer] формат
        - ожидание: абстрактный сериализатор, данные могут быть чем угодно,
          хоть строкой, хоть луа стеком
        - реальность: очень сложно разобраться в такой системе
        - нельзя делать частичную десериализацию
        - нельзя настроить as_map/as_array
        - проблемы со сборкой
    - что делать?
        - serde не использовать
            - мы начали разработку своего трейта, на это нужно время
        - не создавать лишних абстракций

- почему LuaRead/Push <=/=> rmp_serde
    - msgpack array == (A, B, C) == lua multiret != msgpack array
    - enum это геморой

- абстракции -- плохо, мета-программирование на типах -- плохо
    - используйте const if, если возможно
    - делайте проверки в рантайме
        - assert > Err
    - дубликация кода > overabstraction
    - пишите простой код
