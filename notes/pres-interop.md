# Rust/LUA/msgpack interop: почему так сложно?

## Введение

Если слушать главу компании, то мы разрабатываем распределённую субд на расте
(до недавнего времени ещё и сервер приложений, но рынку это оказалось не нужно).
И если очень очень сильно прищуриться, то это действительно так, но всерьёз к
этому маркетинговому лозунгу относиться не стоит. Более точным на мой взгляд
было бы сказать "мы разрабатываем набор расширений для tarantool, которые
позволят делать на нём решения и использовать его как распределённую субд".
Отсюда становится понятно, при чём здесь луа и мсжпак.

Мсжпак это ядро тарантула (буквально, см. src/lib/core/mp_*). Тарантул =
tuple storage, tuple = msgpack. От него мы уже никогда не избавимся.

Луа это де факто язык для расширений и приложений на тарантуле, на нём написаны
управление схемой в тарантуле, модуль шардирования данных vshard, кластер
менеджер cartridge. Поэтому если ты пишешь код под тарантул, тот в любом случае
столкнёшься с луа.

Раст это стрёмная смесь c++ и ml (ocaml, haskel), который набирает популярность
засчёт качественного туллинга (cargo, rust-analyzer) и сказок про бесплатную
эффективность на уровне С одновременно с memory-safety без сборки мусора. На
деле же представляет из себя язык с эффективностью на уровне Go и сборкой мусора
через подсчёт ссылок.

Для кого этот доклад:
   - для людей, которые пишут код на расте и луа и использует msgpack
     (все сотрудники picodata)
   - для людей, которые принимают решения, на чём люди пишут код
     (выбирают технологии)


~~~

Так как тарантул неотрывно связан и с мсжпаком и с луа, мы по крайней мере в
обозримом будущем от них полностью избавиться не сможем. Повторюсь, на луа
написана и часть самого тарантула и значительная часть экосистемы.

А это значит, что если мы хотим создать успешный продукт в таких условиях, мы
должны уметь эффективно пользоваться доступными ресурсами, то есть оперировать
между rust, lua и мсжпаком. Это одна из целей библиотеки tarantool-module.

Но зачем пользователям знать как устроено всё внутри? По-мимо того, что знание =
сила, и что понимание системы на низком уровне даёт много преимуществ? Кроме
этого из-за особенностей наших условий часто возникают ситуации, которые
чисто абстаргировать в библиотеке не получается, из-за которых у пользователей
могут возникуть проблемы с использованием её. А в этом докладе я как раз
расскажу о таких вещах.

Расскажу, почему некоторые вещи получились криво, и почему зачастую сделать
лучше очень сложно.

А также заодно расскажу о нескольких местах, которые можно было сделать лучше,
чтобы вы в будущем не совершали наших ошибок.


~~~

Есть библиотека tlua/tarantool-module, почему она отстой, потому что всё сложно:

Зачем пользователям это знать, и что им с этим делать?

- Зачем:
   - чтобы понимать как работать с библиотекой, и почему она такая кривая
       местами
   - чтобы знать, что делать в местах, где библиотека не помогает
- Что делать:
   - По возможности избегать необходимости в интеропе между луа и растом
   - Всегда выбирать простые решения

## Разница моделей данных rust/lua/msgpack

- lua bool: true/false -- всё просто. На этом простые случаи закончены.
- lua nil: не может быть элементом таблицы
- lua number: double precision floating point number
   - msgpack integer / float
   - rust i8, u8, i16, u16, ..., isize, usize, i128, f32, f64 (NonZeroU64, ..)
- lua string:
   - msgpack string / bytes
   - rust string: String, &str, CString, &CStr, &[u8], OsString, Path, ...
- lua table:
   - sequence (индекс от 1) / hashtable
      - msgpack array / map
      - rust struct, enum, &[T], Vec<T>, HashMap<T>, HashSet<T>
- lua metamethods -> ?
- lua userdata / luajit cdata/ctype

- rust tuple:
   - msgpack array
   - lua sequence/lua multret
- rust struct Named { a: i32, b: String }
   - msgpack map
   - lua hashtable
- rust struct Unnamed(f32, bool) (для чего это вообще существует???)
   - msgpack array???
   - lua sequence??
- rust enum E { A, B, C }
   - msgpack string
   - lua string
- rust enum Expr { Add { l: L, r: R }, Not { e: E } }
   - msgpack map { tag: 'Add', value: { l: L, r: R } }
   - msgpack map { tag: 'Add', l: L, r: R }
   - msgpack map { l: L, r: R }
   - lua ...
- rust enum Expr { Add(L, R), Not(E) }
   - ?
- rust enum Result<T, E> { Ok(T), Err(E) }
- rust enum Option<T> { Some(T), None }
...


## Особенности tarantool-lua:
- box.NULL
- metamethods __serialize
- расширения cdata/userdata: decimal, fiber, tuple, datetime, ...
- встроенные перегруженные функции
- нет поддержки msgpack bytes
- поэтому большую часть нельзя вынести в tlua либу


## Особенности rust
- Serde: дефакто стандартное решение для сер/дериализации: описание
   - сложность модели: абстрактная модель Serializer/Deserializer
   Формат данных        -> [serde] -> struct, enum, Vec<T> ...
   [json,msgpack,...]
   - Не достаточно гибкости для краевых случаев

- Нет интроспекции ни рантайм ни компайлтайм: вместо этого трейты и проц макросы
- Нет специализации для трейтов: нужно явно прописывать реализацию либо
   - для каждого типа по отдельности impl MyTrait for i8; impl MyTrait for u8; impl MyTrait for String; ...
   - не больше одного: impl<T> MyTrait for T

- PartialEq vs Eq / ParitalOrd vs Ord
- Move-semantics/Borrow-checker/Lifetime constraints

## Ошибки проектирования tlua:
- tlua - отдельная библиотека, лучше было внести в tarantool-module
- tlua::Any[Hashable]LuaValue
   - no support for:
      - userdata
      - function
      - cdata
   - lossy:
      - table -> Vec<(Value, Value)>
      - number -> f64/i32
- LuaRead -> WrongType
   - изначально был Option, в случае ошибки получаешь None
   - сейчас не сильно лучше (пример сообщения об ошибке, примеры сообщений из serde_*)
- Параметрический полиморфизм
   - следствие: PushGuard<LuaTable<PushGuard<LuaFunction<PushGuard<...>>>>>
- Push[One][Into] _no_err
